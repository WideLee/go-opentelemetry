//
//
// Tencent is pleased to support the open source community by making tRPC available.
//
// Copyright (C) 2023 THL A29 Limited, a Tencent company.
// All rights reserved.
//
// If you have downloaded a copy of the tRPC source code from Tencent,
// please note that tRPC source code is licensed under the  Apache 2.0 License,
// A copy of the Apache 2.0 License is included in this file.
//
//

// Code generated by trpc-go/trpc-go-cmdline. DO NOT EDIT.
// source: test.proto

package trpc_test_testproto

import (
	"context"
	"fmt"

	_ "trpc.group/trpc-go/trpc-go"
	_ "trpc.group/trpc-go/trpc-go/http"

	"trpc.group/trpc-go/trpc-go/client"
	"trpc.group/trpc-go/trpc-go/codec"
	"trpc.group/trpc-go/trpc-go/server"
	"trpc.group/trpc-go/trpc-go/stream"
)

/* ************************************ Service Definition ************************************ */

// TestServiceService defines service
type TestServiceService interface {
	PingList(*PingRequest, TestService_PingListServer) error
}

func TestServiceService_PingList_Handler(srv interface{}, stream server.Stream) error {
	m := new(PingRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TestServiceService).PingList(m, &testServicePingListServer{stream})
}

type TestService_PingListServer interface {
	Send(*PingResponse) error
	server.Stream
}

type testServicePingListServer struct {
	server.Stream
}

func (x *testServicePingListServer) Send(m *PingResponse) error {
	return x.Stream.SendMsg(m)
}

// TestServiceServer_ServiceDesc descriptor for server.RegisterService
var TestServiceServer_ServiceDesc = server.ServiceDesc{
	ServiceName:  "trpc.test.testproto.TestService",
	HandlerType:  ((*TestServiceService)(nil)),
	StreamHandle: stream.NewStreamDispatcher(),
	Methods:      []server.Method{},
	Streams: []server.StreamDesc{
		{
			StreamName:    "/trpc.test.testproto.TestService/PingList",
			Handler:       TestServiceService_PingList_Handler,
			ServerStreams: true,
		},
	},
}

// RegisterTestServiceService register service
func RegisterTestServiceService(s server.Service, svr TestServiceService) {
	if err := s.Register(&TestServiceServer_ServiceDesc, svr); err != nil {
		panic(fmt.Sprintf("TestService register error:%v", err))
	}
}

/* ************************************ Client Definition ************************************ */

// TestServiceClientProxy defines service client proxy
type TestServiceClientProxy interface {
	PingList(ctx context.Context, req *PingRequest, opts ...client.Option) (TestService_PingListClient, error)
}

type TestServiceClientProxyImpl struct {
	client       client.Client
	streamClient stream.Client
	opts         []client.Option
}

var NewTestServiceClientProxy = func(opts ...client.Option) TestServiceClientProxy {
	return &TestServiceClientProxyImpl{client: client.DefaultClient, streamClient: stream.DefaultStreamClient, opts: opts}
}

func (c *TestServiceClientProxyImpl) PingList(ctx context.Context, req *PingRequest, opts ...client.Option) (TestService_PingListClient, error) {
	ctx, msg := codec.WithCloneMessage(ctx)

	msg.WithClientRPCName("/trpc.test.testproto.TestService/PingList")
	msg.WithCalleeServiceName(TestServiceServer_ServiceDesc.ServiceName)
	msg.WithCalleeApp("test")
	msg.WithCalleeServer("testproto")
	msg.WithCalleeService("TestService")
	msg.WithCalleeMethod("PingList")
	msg.WithSerializationType(codec.SerializationTypePB)

	clientStreamDesc := &client.ClientStreamDesc{}
	clientStreamDesc.StreamName = "PingList"
	clientStreamDesc.ClientStreams = true

	callopts := make([]client.Option, 0, len(c.opts)+len(opts))
	callopts = append(callopts, c.opts...)
	callopts = append(callopts, opts...)

	stream, err := c.streamClient.NewStream(ctx, clientStreamDesc, "/trpc.test.testproto.TestService/PingList", callopts...)
	if err != nil {
		return nil, err
	}
	x := &testServicePingListClient{stream}
	if err := x.ClientStream.SendMsg(req); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}

	return x, nil
}

type TestService_PingListClient interface {
	Recv() (*PingResponse, error)
	client.ClientStream
}

type testServicePingListClient struct {
	client.ClientStream
}

func (x *testServicePingListClient) Recv() (*PingResponse, error) {
	m := new(PingResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}
